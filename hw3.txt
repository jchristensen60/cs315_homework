Script started on Thu 03 Nov 2022 07:15:12 PM MST
[01;34m#=======================================================================#
[1;36m                  Embry-Riddle Aeronautical University         
[01;34m#=======================================================================#
[01;37m  HOSTNAME =[1;36m prclab1.erau.edu  
[01;37m  LOCATION =[01;32m Prescott                      
[01;37m  USER     =[01;35m chrisj60                      
[01;37m  UPTIME   =[01;33m 346 days, 10:59, 19 users, load average hours,  0.07, 0.07, 0.05 minutes  
[01;37m  IP       = [2;36m172.19.241.11  
[01;37m  OS       = [01;31mOracle Linux Server release 7.8  
[01;37m  ARCH     = x86_64                     
[01;37m  KERNEL   = 4.14.35-2047.508.3.el7uek.x86_64                   
[01;37m  UPTRACK  = 4.14.35-2047.515.3.el7uek.x86_64                   
[01;37m  Date     = Thu Nov  3 19:15:12 MST 2022                   
[01;34m  CPUCORES = 6 [01;34m                                    CPU_AVG  = 1%
[021;32m  MEMORY (total) = 7686 Mb     [01;32m                      MEM_AVG  = 17%
[021;32m  SWAP (total)   = 4091 Mb [01;32m                     SWAP_AVG = 22%  
[01;37m  LOAD AVERAGE  = [01;35m0.07, 0.07, 0.05                      
[01;34m#=======================================================================#[0m

             [01;31mUNAUTHORIZED ACCESS TO THIS SYSTEM IS PROHIBITED.
[01;37mAccess to this system is restricted to authorized users only. Unauthorized
[01;37maccess, use, or modification of this system, or any data stored therein is
[01;37mstrictly prohibited by University policies and applicable law.

 [01;31m** [01;33mIf you are not authorized to access this system, exit immediately! [01;31m**

[01;37mUsers of this system expressly consent to activity monitoring. Unauthorized
[01;37musers may be subject to administrative, criminal, or other legal action.

]0;chrisj60@prclab1:~/CS315/CS315_Homework[?1034h[[01;35mchrisj60[m[01;33m@[m[01;36mprclab1[m:[01;33m~/CS315/CS315_Homework[m][31m$[m gcc hw3_modified.c
]0;chrisj60@prclab1:~/CS315/CS315_Homework[[01;35mchrisj60[m[01;33m@[m[01;36mprclab1[m:[01;33m~/CS315/CS315_Homework[m][31m$[m cat hw3_modified.c

/**********************************************************************************************
 * Author:      Jacob M. Christensen
 * Course:      CS315
 * Assignment:  Homework #3
 * Purpose:     Implement four operations for a binary search tree implemented via pointers.
 *                  - Insert
 *                  - In-order traversal
 *                  - Pre-order traversal
 *                  - Find
**********************************************************************************************/

#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>

/* Initializing Binary Search Tree Structure */
typedef struct _BinarySearchTreeNode
{
    int value;
    struct _BinarySearchTreeNode *leftChild;
    struct _BinarySearchTreeNode *rightChild;
} BSTN; // Binary Search Tree Node

/* Initializing Traversal Management Structure */
typedef struct _TraversalStackNode
{
    struct _BinarySearchTreeNode *bstnPtr;
    struct _TraversalStackNode *next;
}TSN; // Traversal Stack Node

/* Prototype Functions */
void splashText();
BSTN *memoryAllocateNewNode();
void search();
void inOrderTraversal();
void preOrderTraversal();
void insert();
void traversalStackPush();
BSTN *traversalStackPop();

/*********************************************************************************************/
int main()
{
    BSTN *rootPtr = NULL;
    int userInput = 0;
    char charToFind, charToInsert;
    bool quitProgram = false;

    splashText();
    do {

        printf("----------------------------------------\n"
               " Insert[1]        Find[2]       Quit[3] \n"
               "----------------------------------------\n"
               " Command: ");
        scanf("%d", &userInput);

        switch (userInput) {

        case 1: /* Insert Value in BST */
            printf(" * Enter Character to Insert: ");
            scanf(" %c", &charToInsert);
            insert(&rootPtr, charToInsert);

            // Display Traversal Patterns
            inOrderTraversal(rootPtr);
            preOrderTraversal(rootPtr);
            break;
        
        case 2: /* Search Value in BST */
            printf(" * Enter Character to Find: ");
            scanf(" %c", &charToFind);
            search(rootPtr, charToFind);
            break;
        
        case 3: /* Terminate Program */
            quitProgram = true;
            break;

        default:
            printf(" *** Invalid Entry ***\n");
            break;
        }

    } while (!quitProgram);

    return 0;
}

/*********************************************************************************************/
void splashText()
{
    printf("CS315 Homework v3 -- Binary Search Trees\n");
}

/*********************************************************************************************/
BSTN *memoryAllocateNewNode(int nodeValue)
{
    BSTN *newNode = malloc(sizeof(BSTN));
    newNode->value = nodeValue;
    newNode->leftChild = NULL;
    newNode->rightChild = NULL;
    
    return newNode;
}

/*********************************************************************************************/
void search(BSTN *rootPtr, int searchValue)
{
    if (rootPtr == NULL) {
        printf("Character Not in Tree\n\n");
    }
    else if (searchValue == rootPtr->value) {
        printf("Character Found in Tree\n\n");
    }
    else if (searchValue < rootPtr->value) {
        search(rootPtr->leftChild, searchValue);
    }
    else {
        search(rootPtr->rightChild, searchValue);
    }
}

/*********************************************************************************************/
void inOrderTraversal(BSTN *rootPtr)
{
    BSTN *travelPtr = rootPtr;
    TSN *traversalStackTop = NULL;

    printf(" * In-Order Traversal: ");

    traversalStackPush(travelPtr, &traversalStackTop);

    while (traversalStackTop) {

        while (travelPtr->leftChild) {
            traversalStackPush(travelPtr->leftChild, &traversalStackTop);
            travelPtr = travelPtr->leftChild;
        }

        travelPtr = traversalStackPop(&traversalStackTop);
        printf("%c ", travelPtr->value);

        while (travelPtr->rightChild == NULL && traversalStackTop) {
            travelPtr = traversalStackPop(&traversalStackTop);
            printf("%c ", travelPtr->value);
        }
        if (travelPtr->rightChild) {
            traversalStackPush(travelPtr->rightChild, &traversalStackTop);
            travelPtr = travelPtr->rightChild;
        }
    }
    printf("\n");
}

/*********************************************************************************************/
void preOrderTraversal(BSTN *rootPtr)
{
    BSTN *travelPtr = rootPtr;
    TSN *traversalStackTop = NULL;

    printf(" * Pre-Order Traversal: ");

    traversalStackPush(travelPtr, &traversalStackTop);

    while (traversalStackTop) { // != NULL
        travelPtr = traversalStackPop(&traversalStackTop);
        printf("%c ", travelPtr->value); // Visit the Root
        if (travelPtr->rightChild) { // != NULL
            traversalStackPush(travelPtr->rightChild, &traversalStackTop);
        }
        if (travelPtr->leftChild) { // != NULL
            traversalStackPush(travelPtr->leftChild, &traversalStackTop);
        }
    }
    printf("\n");
}

/*********************************************************************************************/
void insert(BSTN **rootPtr, int charToInsert)
{
    if (*rootPtr == NULL) {
        *rootPtr = memoryAllocateNewNode(charToInsert);
    }
    else if (charToInsert == (*rootPtr)->value) {
        printf(" * Character Already in Tree\n");
    }
    else if (charToInsert < (*rootPtr)->value) {
        insert(&((*rootPtr)->leftChild), charToInsert);
    }
    else { // valueToInsert > (*rootPtr)->value
        insert(&((*rootPtr)->rightChild), charToInsert);
    }
    // insert(valueToInsert < rootPtr->data ? rootPtr->leftChild : rootPtr->rightChild, valueToInsert);
}

/*********************************************************************************************/
void traversalStackPush(BSTN *travelPtr, TSN **traversalStackTop)
{
    TSN *temp = malloc(sizeof(TSN));
    temp->bstnPtr = travelPtr;
    temp->next = *traversalStackTop;
    *traversalStackTop = temp;
}

/*********************************************************************************************/
BSTN *traversalStackPop(TSN **traversalStackTop)
{
    TSN *temp = *traversalStackTop;
    BSTN *returnValue = (*traversalStackTop)->bstnPtr;
    if (*traversalStackTop) { // != NULL
        *traversalStackTop = (*traversalStackTop)->next;
        free(temp);
        return returnValue;
    }
    else {
        return NULL;
    }
}
]0;chrisj60@prclab1:~/CS315/CS315_Homework[[01;35mchrisj60[m[01;33m@[m[01;36mprclab1[m:[01;33m~/CS315/CS315_Homework[m][31m$[m a.out
CS315 Homework v3 -- Binary Search Trees
----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 1
 * Enter Character to Insert: m
 * In-Order Traversal: m 
 * Pre-Order Traversal: m 
----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 1
 * Enter Character to Insert: d
 * In-Order Traversal: d m 
 * Pre-Order Traversal: m d 
----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 1
 * Enter Character to Insert: g
 * In-Order Traversal: d g m 
 * Pre-Order Traversal: m d g 
----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 1
 * Enter Character to Insert: r
 * In-Order Traversal: d g m r 
 * Pre-Order Traversal: m d g r 
----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 1
 * Enter Character to Insert: p
 * In-Order Traversal: d g m p r 
 * Pre-Order Traversal: m d g r p 
----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 1
 * Enter Character to Insert: b
 * In-Order Traversal: b d g m p r 
 * Pre-Order Traversal: m d b g r p 
----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 1
 * Enter Character to Insert: x
 * In-Order Traversal: b d g m p r x 
 * Pre-Order Traversal: m d b g r p x 
----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 1
 * Enter Character to Insert: v
 * In-Order Traversal: b d g m p r v x 
 * Pre-Order Traversal: m d b g r p x v 
----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 2
 * Enter Character to Find: g
Character Found in Tree

----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 2
 * Enter Character to Find: z
Character Not in Tree

----------------------------------------
 Insert[1]        Find[2]       Quit[3] 
----------------------------------------
 Command: 3
]0;chrisj60@prclab1:~/CS315/CS315_Homework[[01;35mchrisj60[m[01;33m@[m[01;36mprclab1[m:[01;33m~/CS315/CS315_Homework[m][31m$[m exit
exit

Script done on Thu 03 Nov 2022 07:16:37 PM MST
